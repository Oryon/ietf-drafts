<?xml version="1.0" encoding="iso-8859-1" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc ipr="trust200902"
    docName="draft-ietf-homenet-prefix-assignment-02"
    category="std">

<?rfc toc="yes"?> <?rfc symrefs="yes"?> <?rfc autobreaks="yes"?>
<?rfc tocindent="yes"?> <?rfc compact="yes"?> <?rfc subcompact="no"?>

<front>

<title abbrev="Prefix Assignment Algorithm">Distributed Prefix Assignment Algorithm</title>

<author initials="P" surname="Pfister" fullname="Pierre Pfister">
<organization>Cisco Systems</organization>
<address>
<postal>
<street/>
<city>Paris</city>
<country>France</country>
</postal> 		
<email>pierre.pfister@darou.fr</email>
</address>
</author>

<author initials="B" surname="Paterson" fullname="Benjamin Paterson">
<organization>Cisco Systems</organization>
<address>
<postal>
<street/>
<city>Paris</city>
<country>France</country>
</postal> 		
<email>benjamin@paterson.fr</email>
</address>
</author>

<author initials="J" surname="Arkko" fullname="Jari Arkko">
<organization>Ericsson</organization>
<address>
<postal>
<street/>
<city>Jorvas</city> <code>02420</code>
<country>Finland</country>
</postal>
<email>jari.arkko@piuha.net</email>
</address>
</author>

<date month="December" year="2014" />

<keyword>IPv6</keyword>
<keyword>Homenet</keyword>
<keyword>Prefix Assignment</keyword>

<abstract>
    
    <t>This document specifies a distributed algorithm for automatic prefix assignment. Given a set of delegated prefixes, it assigns exactly one prefix per link and per delegated prefix whenever at least one directly connected node assigns an available prefix to the given link. Additionaly, nodes may assign available prefixes from delegated prefixes for other private purposes. The algorithm eventually converges and ensures that all assigned prefixes do not overlap.</t>

</abstract>

</front>
<middle>

<section anchor="intro" title="Introduction">
    
    <t>This document specifies a distributed algorithm for automatic prefix assignment. Given a set of delegated prefixes, it ensures that the following assertions are eventually true:
        <list style="symbols">
            <t>The algorithm assigns zero or one prefix per link and per delegated prefix.</t>
            <t>For any given link and delegated prefix, exactly one prefix is assigned whenever at least one directly connected node assigns an available prefix to the given link. When multiple nodes assign different prefixes from the same delegated prefix on the same link, the assignment with the highest priority is kept and other assignments are removed.</t>
            <t>Any node may assign any number of available prefixes for their private use.</t>
            <t>Assigned prefixes are stable.</t>
            <t>Assigned prefixes do not overlap. When multiple nodes assign overlaping prefixes, the assignment with the highest priority is kept and other assignments are removed.</t>
        </list>
    </t>
    
    <t>The prefix assignment algorithm requires that participating nodes share information through a flooding mechanism. If the flooding mechanism ensures that all messages are propagated to all nodes faster than a given timing upper bound, the algorithm also ensures that all assigned prefixes used for critical operations are assigned forever, unless another node  causes renumbering by assigning a colliding prefix with an higher assignment priority, or the topology changes and renumbering cannot be avoided.</t>

</section>

<section anchor="terminology" title="Terminology">
    <t>In this document, the key words "MAY", "MUST, "MUST NOT", "OPTIONAL",
        "RECOMMENDED", "SHOULD", and "SHOULD NOT", are to be interpreted as
        described in <xref target='RFC2119' />.</t>
    
    <t>
        This document makes use of the following terminology:
        <list style="hanging">
        
        <t hangText="Advertised Prefix: ">A prefix advertised by another node through the Flooding Mechanism. It is associated with an Advertised Prefix Priority and whether it is assigned to a directly connected Shared Link (and which one if any). Note that an Assigned Prefix which is advertised is not an Advertised Prefix, as it is advertised by the local node.</t>
        
        <t hangText="Advertised Prefix Priority: ">All Advertised Prefixes are associated with a priority. Whenever multiple Advertised Prefixes are not coherant with the correctness of the algorithm, all Advertised Prefixes but the one with the highest priority will eventually be removed. In case of tie, the Node ID is used as tie breaker (greatest is kept). In order to ensure convergence, the range of priority values MUST have an upper bounded.</t>
        
        <t hangText="Assigned Prefix: ">A prefix assigned to a Shared or Private Link. It represents a local decision to assign a given prefix from a given Delegated Prefix to a given Link. The algorithm ensures there is no more than one Assigned Prefix per Delegated Prefix and Link pair.</t>
        
        <t hangText="Applied (Assigned Prefix): ">When an Assigned Prefix is applied, it MAY be used (e.g., for host configuration, routing protocol configuration, prefix delegation). When not applied, it MUST NOT be used for any other purposes than the prefix assignment algorithm. Each Assigned Prefix is associated with a timer (Apply Timer) used to apply the Assigned Prefix. An Assigned Prefix is unapplied when destroyed.</t>
        
        <t hangText="Advertised (Assigned Prefix): ">The Assigned Prefix is advertised through the Flooding Mechanism as assigned to its associated Link. An advertised Assigned Prefix MUST be associated with an Advertised Prefix Priority.</t>
        
        <t hangText="Backoff Timer: ">Every Delegated Prefix and Link pair is associated with a timer counting down to zero. It is used to avoid multiple nodes from making colliding assignments by delaying the creation of new Assigned Prefixes by a random amount of time.</t>
        
        <t hangText="Delegated Prefix: ">A prefix provided to the algorithm and used as a prefix pool for Assigned Prefixes.</t>
        
        <t hangText="Flooding Mechanism: ">A mechanism implementing reliable broadcast and used to advertise Assigned Prefixes.</t>
        
        <t hangText="Flooding Delay: ">Optional value provided by the Flooding Protocol indicating a deterministic or likely upper bound of the information propagation delay.</t>
        
        <t hangText="Link: ">Each Node is directly connected to a set of Links. A Link is either Shared or Private.</t>
        
        <t hangText="Private Link: ">A Private Link is an abstract concept defined for the sake of this document. It allows nodes to make assignments for their private use or delegation. For instance, every DHCPv6-PD <xref target='RFC3633' /> client MAY be considered as a different Private Link.</t>
        
        <t hangText="Renumbering: ">Renumbering happens when an Assigned Prefix which was applied is destroyed. It is undesirable as it usually implies reconfiguring routers or hosts.</t>
        
        <t hangText="Node ID: ">A value identifying a given participating node. The set of identifiers MUST be strictly and totally ordered (have a comparison operation).</t>
        
        <t hangText="Shared Link: ">A Link multiple nodes are connected to. The Flooding Mechanism MUST make sure that when a Node advertises an Assigned Prefix as assigned to a given Shared Link, all other nodes directly connected to the Shared Link know the prefix is assigned to the same given Shared Link. Most of the time, a Shared Link would consist in a multi-access link or point-to-point link, virtual or physical, requiring prefixes to be assigned to.</t>
        
        </list>
    </t>
    
</section>

<section title="Applicability statement">
    <t>All nodes MUST run a common Flooding Mechanism in order to share advertised Assigned Prefixes. The set of participating nodes is defined as the set of nodes participating in the Flooding Mechanism.</t>
    
    <t>The Flooding Mechanism MUST:
        <list style="symbols">
            <t>Provide a way to flood Assigned Prefixes assigned to a directly connected Link along with their respective Advertised Prefix Priority and the Node ID of the node which advertises it.</t>
            <t>Specify whether an Advertised Prefix was assigned to a directly connected Shared Link, and if so, on which one.</t>
        </list>
        In addition, a Flooding Delay SHOULD be specified and respected in order to avoid undesired renumbering. If not specified, or whenever the Flooding Mechanism is unable to respect the provided delay, renumbering may happen. As such delay often depends on the size of the network, it MAY change over time.
    </t>
    
    <t>The algorithm supports dynamically changing topologies:
        <list style="number">
            <t>Nodes may join or leave the set of participating nodes.</t>
            <t>Nodes may join or leave Links.</t>
            <t>Links may be joined or split.</t>
        </list>
    </t>
    
    <t>A set of disjoint Delegated Prefixes MUST be provided to all participating nodes. It MAY change over time and be different from one node to another at some point it time, but the correctness of the algorithm is not ensured unless nodes eventually agree on a given set of disjoint Delegated Prefixes.</t>
    
    <t>Each node MUST have a Node ID. Node IDs MUST be unique in order to ensure the correctness of the algorithm. Node IDs MAY be changed (e.g. in order to resolve Node ID collision), in which case the algorithm MUST be run.</t>
    
    <t>The algorithm ensures that whenever the Flooding Delay is provided and respected, and in the absence of topology change or delegated prefix removal, renumbering never happens.</t>
    
    <t>The prefix assignment algorithm can be applied to any prefix-based address space and can be used to manage multiple addressing spaces simultaneously. For instance, an implementation can make use of IPv4-mapped IPv6 addresses <xref target='RFC4291' /> in order to manage both IPv4 and IPv6 prefix assignment simultaneously.</t>
    
</section>

<section title="Algorithm Specification">
    
    <t>This section specifies the behavior of nodes implementing the prefix assignment algorithm.</t>
    
    <t>Implementations of the prefix assignment algorithm may vary from very basic to highly customisable. A fairly poor implementation may only act uppon assignments made by other nodes, more complex implementations may support custom policies such as custom prefix selection or act specifically in case of address space exhaustion.</t>
    
    <section title="Algorithm Terminology">
        <t>The algorithm makes use of the following terms:
            
            <list style="hangText">
                <t hangText="Best Assignment: ">For a given Delegated Prefix and Link, the Best Assignment is (if any) the Advertised Prefix:
                    <list style="symbols">
                        <t>Included in the Delegated Prefix.</t>
                        <t>Assigned on the given Link.</t>
                        <t>Having the greatest priority (and, in case of tie, the prefix advertised by the node with the greatest Node ID among all prefixes with greatest priority).</t>
                    </list>
                </t>
                
                <t hangText="Current Assignment: ">For a given Delegated Prefix and Link, the Current Assignment is the Assigned Prefix (if any) included in the Delegated Prefix and assigned to the given Link.</t>
                
                <t hangText="Precedence: ">An Advertised Prefix takes precedence over an Assigned Prefix if and only if one or more of the following conditions are met:
                    <list style="symbols">
                        <t>The Assigned Prefix is not advertised.</t>
                        <t>The Assigned Prefix is advertised and the Advertised Prefix Priority from the Advertised Prefix is strictly greater than the Advertised Prefix Priority from the Assigned Prefix.</t>
                        <t>The Assigned Prefix is advertised, the priorities are equal, and the Node ID from the node advertising the Advertised Prefix is strictly greater than the local Node ID.</t>
                    </list>
                </t>
                
                <t hangText="Valid (Assigned Prefix)">An Assigned Prefix is valid if and only if all the following conditions are met:
                    <list style="symbols">
                        <t>No Advertised Prefix including or included in the Assigned Prefix takes precedence over the Assigned Prefix.</t>
                        <t>No Advertised Prefix including or included in the same Delegated Prefix than the Assigned Prefix and assigned to the same Link takes precedence over the considered Assigned Prefix.</t>
                    </list>
                </t>
            </list>
            
        </t>
    </section>
    
    <section anchor="algo" title="Prefix Assignment Algorithm Routine">
        <t>This section specifies the prefix assignment algorithm routine. The routine MUST be run for any Delegated Prefix/Link pair whenever:
            <list style="symbols">
                <t>An Advertised Prefix including or included in the considered Delegated Prefix, and advertised by another node, is added or removed.</t>
                <t>The Backoff Timer associated with the considered Delegated Prefix/Link pair fires while there is no Current Prefix associated with the given pair.</t>
                <t>The considered Delegated Prefix is added.</t>
                <t>The considered Link is added.</t>
                <t>The Node ID is modified.</t>
                <t>The Current Assignment for the given Delegated Prefix/Link pair was destroyed due to the creation of an overriding assignment (see <xref target='override' />).</t>
            </list>
        </t>
        
        <t>In order to execute the routine for a given Delegated Prefix/Link pair, first look for the Best Assignment and Current Assignment associated with the Delegated Prefix/Link pair, then execute the corresponding case:
            <list style="numbers">
                <t>If there is no Best Assignment and no Current Assignment: Decide whether the creation of a new assignment for the given Delegated Prefix/Link pair is desired. If it is not desired, stop the routine. Otherwise, do the following:
                    <list style="symbols">
                        <t>If the routine was executed because the Backoff Timer fired, continue the execution.</t>
                        <t>Otherwise, set the Backoff Timer to some random delay between zero and BACKOFF_MAX_DELAY (see <xref target='variables' />) and return.</t>
                    </list>
                    At this point, select a prefix for the new assignment (see <xref target='random' /> for guidance regarding prefix selection). This prefix MUST be included in or be equal to the considered Delegated Prefix and MUST NOT include or be included in any Advertised Prefix. If a suitable prefix is found, use it to create a new Assigned Prefix:
                    <list style="symbols">
                        <t>Assigned to the considered Link.</t>
                        <t>Not applied.</t>
                        <t>The Apply Timer set to '2 * Flooding Delay'.</t>
                        <t>Advertised with some selected Advertised Prefix Priority.</t>
                    </list>
                </t>
                <t>If there is a Best Assignment but no Current Assignment: Cancel the Backoff Timer and use the prefix from the Best Assignment to create a new Assigned Prefix:
                    <list style="symbols">
                        <t>Assigned to the considered Link.</t>
                        <t>Not applied.</t>
                        <t>The Apply Timer set to '2 * Flooding Delay'.</t>
                        <t>Not advertised.</t>
                    </list>
                </t>
                <t>If there is a Current Assignment and either no Best Assignment or a Best Assignment which does not take precedence over the Current Assignment:
                    <list style="symbols">
                        <t>If the Current Assignment is not valid, destroy it and execute case 1 or 2, depending on whether there is a Best Assignment.</t>
                        <t>If the Current Assignment is valid and advertised, do nothing.</t>
                        <t>If the Current Assignment is valid and not advertised, the node MAY either:
                            <list style="symbols">
                                <t>Destroy it and execute case 1 in order to create a different assignment.</t>
                                <t>Adopt the prefix by canceling the Apply Timer and set the Backoff Timer to some random delay between zero and BACKOFF_MAX_DELAY (see <xref target='variables' />).</t>
                            </list>
                        </t>
                    </list>
                </t>
                <t>If there is a Current Assignment and a Best Assignment which takes precedence over the Current Assignment:
                    <list style="symbols">
                        <t>Cancel the Backoff Timer.</t>
                        <t>If the two prefixes are identical, set the Current Assignment as not advertised. If the Current Assignment is not applied and the Apply Timer is not set, set the Apply Timer to '2 * Flooding Delay'.</t>
                        <t>If the two prefixes are not identical, destroy the Current Assignment and go to case 2.</t>
                    </list>
                </t>
            </list>
        </t>
    </section>
    
    
    <section anchor="override" title="Overriding and Destroying Existing Assignments">
        <t>In addition to the behavior specified in <xref target='algo' />, a node MAY execute the following procedures:
            <list style="hangText">
                <t hangText="Overriding Existing Assignments: ">For any given Link and Delegated Prefix, a node MAY create a new Assigned Prefix such that:
                    <list style="symbols">
                        <t>The Current Assignment, if any, and all existing Assigned Prefixes which include or are included inside the chosen prefix are destroyed.</t>
                        <t>It is not applied with the Apply Timer set to '2 * Flooding Delay'.</t>
                        <t>It is advertised with an Advertised Prefix Priority great enough such that the Assigned Prefix is valid once advertised.</t>
                    </list>
                    In order to ensure algorithm convergence:
                    <list style="symbols">
                        <t>This procedure MUST NOT be executed unless there is a change in the node configuration, a Link is added, or an Advertised Prefix advertised by another node is added or removed.</t>
                        <t>The chosen Advertised Prefix Priority for the new Assigned Prefix SHOULD be greater than all priorities from the destroyed Assigned Prefixes. If not, simple topologies with only two nodes may not converge. Nodes which do not respect this rule MUST implement a mechanism which detects whether the distributed algorithm do not converge and, whenever this would happen, stop creating overriding Assigned Prefixes causing the destruction of other Assigned Prefixes. The specifications for such safety procedures are out of the scope of this document.</t>
                    </list>
                </t>
                <t hangText="Removing an Assigned Prefix: ">A node MAY destroy any Assigned Prefix which is being advertised. Such an event reflects the desire from a node to not assign a prefix from a given Delegated Prefix to a given Link anymore. In order to ensure algorithm convergence, such procedure MUST NOT be executed unless there was a change in the node configuration. Additionaly, whenever an Assigned Prefix is removed this way, the prefix assignment algorithm routine MUST be run for the Delegated Prefix/Link pair associated with the deleted Assigned Prefix.</t>
            </list>
        
        </t>
        <t>These procedures are optional. They could be used for diverse purposes, e.g., for providing custom prefix assignment configuration or reacting to prefix space exhaustion (by overriding short Assigned Prefixes and assigning longer ones).</t>
    </section>
    
    <section title="Other Events">
        <t>When the Apply Timer fires, the associated prefix MUST be applied and MAY therefore be used for other purposes.</t>
        
        <t>When the Backoff Timer associated with a given Delegated Prefix/Link pair fires while there is a Current Prefix associated with the same pair, the Current Prefix MUST be advertised with some associated Advertised Prefix Priority and, if the prefix is not applied, the Apply Timer MUST be set to '2 * Flooding Delay'.</t>
        
        <t>When a Delegated Prefix is removed from the set of Delegated Prefixes, all Assigned Prefixes included in the removed Delegated Prefix MUST be destroyed.</t>
        
        <t>When a Delegated Prefix is replaced by a Delegated Prefixes which includes or is included in the deleted Delegated Prefix, all Assigned Prefixes which were included in the deleted Delegated Prefix but are not included in the added Delegated Prefix MUST be destroyed. Others MAY be kept.</t>
        
        <t>When a Link is removed. All Assigned Prefixes assigned to that Link MUST be destroyed.</t>
    </section>
    
    <section anchor="static" title="Static Configuration Example">
        <t>This section describes an example of how custom configuration of the prefix assignment algorithm may be implemented.</t>
        <t>Configuration is specified as a finite set of rules. A rule is defined as:
            <list style="symbols">
                <t>A prefix to be used.</t>
                <t>A Link on which the prefix may be assigned.</t>
                <t>An Assigned Prefix Priority (smallest possible Assigned Prefix Priority if the entry may not override other Assigned Prefixes).</t>
                <t>A rule priority (0 if the entry may not override existing Advertised Prefixes).</t>
            </list>
            
            In order to ensure the convergence of the algorithm, the Assigned Prefix Priority MUST be an increasing function (not necessarily strictly) of the configuration rule priority (i.e. the greater is the configuration rule priority, the greater the Assigned Prefix Priority must be).
        </t>
        <t>Each Assigned Prefix is associated with a rule priority. Assigned Prefixes which are created as specified in <xref target='algo' /> are given a rule priority of 0.</t>
        <t>Whenever the configuration is changed or the prefix assignment algorithm routine is run: For each Link/Delegated Prefix pair, look for the configuration entry with the highest configuration entry priority such that:
            <list style="symbols">
                <t>The prefix specified in the configuration entry is included in the considered Delegated Prefix.</t>
                <t>The Link specified in the configuration entry is the considered Link.</t>
                <t>All the Assigned Prefixes which would need to be destroyed in case a new Assigned Prefix is created from that configuration entry (as specified in <xref target='override' />) have an associated rule priority which is strictly lower than the one of the considered configuration entry.</t>
                <t>The assignment would be valid when advertised with an Advertised Prefix Priority equal to the one specified in the configuration rule.</t>
            </list>
            If a rule is found, a new Assigned Prefix is created based on that rule in conformance with <xref target='override' />. The new Assigned Prefix is associated with the Advertised Prefix Priority and the rule priority specified in the considered configuration rule.
        </t>
        
        <t>Note that the use of rule priorities ensures the convergence of the algorithm.</t>
    </section>
    
</section>

<section anchor="random" title="Prefix Selection Considerations">
    <t>When the prefix assignment algorithm routine specified in <xref target='algo' /> requires a new prefix to be selected, the prefix MUST be selected either:
            <list style="symbols">
                <t>Among prefixes which were previously assigned and applied on the considered Link.</t>
                <t>Randomly, picked in a set of at least RANDOM_SET_SIZE (see <xref target='variables' />) candidate prefixes. If less than RANDOM_SET_SIZE candidates can be found, the prefix MUST be picked among all candidates.</t>
                <t>Based on some custom selection process specified in the configuration.</t>
            </list>
        
        A simple implementation MAY randomly pick the prefix among all available prefixes, but this strategy is inefficient in terms of address space use as a few long prefixes may exhaust the pool of available short prefixes.</t>
    
    <t>The rest of this section describes a more efficient approach which MAY be applied any time a node needs to pick a prefix for a new assignment. The two following definitions are used:
        <list style="hangText">
            <t hangText="Available prefix: ">The prefix A/N is available if and only if A/N does not include and is not included in any Assigned or Advertised Prefix but A/(N-1) does (or N equals 0 and there is no Assigned or Advertised Prefixes at all).</t>
            <t hangText="Candidate prefix: ">A prefix which is included in or is equal to an available prefix.</t>
        </list>
    </t>
    
    <t>The procedure described in this section takes the three following criteria into account:
        <list style="hangText">
            <t hangText="Stability: ">In some cases, it is desirable that the selected prefix remains the same accross executions and reboots. For this purpose, multiple prefix selection tentatives may be done using prefixes previously applied on the Link and stored in stable storage or using pseudo-random prefixes generated based on node and Link specific values.</t>
            <t hangText="Randomness: ">When no stored or pseudo-random prefix is chosen, a prefix may be randomly picked among RANDOM_SET_SIZE candidates of desired length. If less than RANDOM_SET_SIZE candidates can be found, the prefix is picked among all candidates.</t>
            <t hangText="Addressing-space usage efficiency: ">In the process of assigning prefixes, a small set of badly chosen long prefixes may easily prevent any shorter prefix from being assigned. For this reason, the set of RANDOM_SET_SIZE candidates is created from the set of available prefixes with longest prefix lengths and, in case of tie, privileging small prefix values.</t>
        </list>
    </t>
    
    <t>When executing the procedure, do as follows:
        <list style="numbers">
            <t>For each prefix stored in stable-storage, check if the prefix is included in or equal to an available prefix. If so, pick that prefix and stop.</t>
            <t>For each prefix length, count the number of available prefixes of the given length.</t>
            <t>If the desired prefix length was not specified, select one. The available prefixes count computed previously may be used to help picking a prefix length such that:
                    <list style="symbols">
                        <t>There is at least one candidate prefix.</t>
                        <t>The prefix length is chosen great enough to not exhaust the address space.</t>
                    </list>
                Let N be the chosen prefix length.</t>
            <t>Iterate over available prefixes starting with prefixes of length N down to length 0 and create a set of RANDOM_SET_SIZE candidate prefixes of length exactly N included in or equal to available prefixes. The end goal here is to create a set of RANDOM_SET_SIZE candidate prefixes of length N included in a set of available prefixes of maximized prefix length. In case of a tie, smaller prefixes are prefered.</t>
            <t>For each pseudo-random prefix, check if the prefix is included in or is equal to an available prefix. If so, pick that prefix and stop.</t>
            <t>Choose a random prefix from the set of selected candidates.</t>
        </list>
    </t>
    
    <t>The complexity of this procedure is equivalent to the complexity of iterating over available prefixes. Such operation may be accomplished in linear time, e.g., by storing Advertised and Assigned Prefixes in a binary trie.</t>
    
</section>

<section anchor="variables" title="Algorithm Parameters">
    <t>This document does not provide values for BACKOFF_MAX_DELAY and RANDOM_SET_SIZE. The algorithm ensures convergence and correctness for any chosen values, even when these are different from node to node. They MAY be adjusted depending on the context, providing a tradeoff between convergence time, efficient addressing, low verbosity (through the Flooding Protocol), and low collision probability.</t>
    
    <t>BACKOFF_MAX_DELAY represents the maximum backoff time a node may wait before making a new assignment. The greater the BACKOFF_MAX_DELAY, the lower the collision probability and the verbosity, but the longer the convergence time.</t>
    <t>RANDOM_SET_SIZE represents the desired size of the set a random prefix will be picked from. The greater RANDOM_SET_SIZE, the better the convergence time and the lower the collision probability, but the worse the addressing-space usage efficiency.</t>
</section>

<section title="Security Considerations">
    <t>The prefix assignment algorithm functions on top of two possibly distinct mechanisms, the Flooding Mechanism and the Node ID assignment mechanism. In order to operate securely:
        <list>
            <t>An attacker MUST NOT be able to publish Advertised Prefixes through the flooding mechanism. Otherwise, it may do the following:
                <list style="symbols">
                    <t>Publish a single overriding assignment for a whole Delegated Prefix or for the whole address space, thus preventing any node from assigning prefixes to Links.</t>
                    <t>Quickly publish and remove Advertised Prefixes, generating traffic at the Flooding Mechanism layer and causing multiple executions of the prefix assignment algorithm in all participating nodes.</t>
                    <t>Publish and remove Advertised Prefixes in order to prevent the convergence of the algorithm.</t>
                </list>
            </t>
            <t>An attacker MUST NOT be able to prevent other nodes from accessing a portion or the whole set of Advertised Prefixes. Such an attack may compromise the correctness of the execution.</t>
            <t>On the Node ID size, an attacker MUST NOT be able to do the following:
                <list style="symbols">
                    <t>Cause repetitive Node ID changes resulting in traffic generation at the Flooding Mechanism layer and multiple executions of the prefix assignment algorithm in all participating nodes.</t>
                    <t>Publish Advertised Prefixes using a Node ID used by another node, preventing the correctness and convergence of the execution.</t>
                </list>
            </t>
        </list>
    </t>
    <t>Whenever the security of the Flooding Mechanism and Node ID assignment mechanism could not be ensured, the convergence of the algorithm may be prevented. In environments where such attacks may be performed, the execution of the prefix assignment algorithm routine SHOULD be rate limited.</t>
</section>


</middle>

<back>

<references title="Normative References">
  <?rfc include="reference.RFC.2119.xml"?>
</references>

<references title="Informative References">
  <?rfc include="reference.RFC.4291.xml"?>
  <?rfc include="reference.RFC.3633.xml"?>
</references>

<section title="Acknowledgments">
	
<t>The authors would like to thank those who participated in the previous document's version development as well as the present one. In particular, the authors would like to thank Tim Chown, Fred Baker, Mark Townsley, Lorenzo Colitti, Ole Troan, Ray Bellis, Markus Stenberg, Wassim Haddad, Joel Halpern, Samita Chakrabarti, Michael Richardson, Anders Brandt, Erik Nordmark, Laurent Toutain, Ralph Droms, Acee Lindem and Steven Barth for interesting discussions and document review.</t>

</section>

</back>
</rfc>
