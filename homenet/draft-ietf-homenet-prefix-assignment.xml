<?xml version="1.0" encoding="iso-8859-1" ?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc ipr="trust200902"
    docName="draft-ietf-homenet-prefix-assignment-07"
    category="std">

<?rfc toc="yes"?> <?rfc symrefs="yes"?> <?rfc autobreaks="yes"?>
<?rfc tocindent="yes"?> <?rfc compact="yes"?> <?rfc subcompact="no"?>

<front>

<title abbrev="Prefix Assignment Algorithm">Distributed Prefix Assignment Algorithm</title>

<author initials="P" surname="Pfister" fullname="Pierre Pfister">
<organization>Cisco Systems</organization>
<address>
<postal>
<street/>
<city>Paris</city>
<country>France</country>
</postal> 		
<email>pierre.pfister@darou.fr</email>
</address>
</author>

<author initials="B" surname="Paterson" fullname="Benjamin Paterson">
<organization>Cisco Systems</organization>
<address>
<postal>
<street/>
<city>Paris</city>
<country>France</country>
</postal> 		
<email>paterson.b@gmail.com</email>
</address>
</author>

<author initials="J" surname="Arkko" fullname="Jari Arkko">
<organization>Ericsson</organization>
<address>
<postal>
<street/>
<city>Jorvas</city> <code>02420</code>
<country>Finland</country>
</postal>
<email>jari.arkko@piuha.net</email>
</address>
</author>

<date month="August" year="2015" />

<keyword>IPv6</keyword>
<keyword>Homenet</keyword>
<keyword>Prefix Assignment</keyword>

<abstract>
    <!-- IP prefix assignment often relies on human touch or centralized address management systems.  -->
    <t>This document specifies a distributed algorithm for dividing a set of prefixes in a manner that allows for automatic assignment of sub-prefixes that are unique and non-overlapping. Used in conjunction with a protocol that provides flooding of information among a set of participating nodes, prefix configuration within a network may be automated.</t>

</abstract>

</front>
<middle>

<section anchor="intro" title="Introduction">

	<t>This document specifies a distributed algorithm for automatic prefix assignment. The algorithm provides a generic alternative to centralized (human or software based) approaches for network prefix and address assignment. Although it does not require to be configured to operate properly, it supports custom configuration by means of variable priority assignments, and can therefore be used in fully autonomic as well as configured networks. This document focuses on the algorithm itself and therefore leaves as out of scope context-specific considerations, such as the process of selecting a prefix value and length when making a new assignment.</t>

    <t>The algorithm makes use of a flooding mechanism allowing participating Nodes to advertise prefixes assigned to the links they are directly connected to or for other purposes, e.g., for private assignment or prefix delegation. Advertising a prefix therefore serves two purposes. It is a claim that a prefix is in use, meaning that no other Node may advertise an overlapping prefix (unless it has a greater priority). And it is a way for other Nodes to know which prefixes have been assigned to the links they are directly connected to.</t>

    <t>The algorithm is given a set of delegated prefixes, and ensures that the following assertions are satisfied after a finite convergence period:
        <list style="numbers">
            <t>At most one prefix from each delegated prefix is assigned to each link.</t>
            <t>Assigned prefixes are non-overlapping (i.e., an assigned prefix never includes another assigned prefix).</t>
            <t>Assigned prefixes do not change in the absence of topology or configuration changes.</t>
        </list>
        In the rest of this document the two first conditions are referred to as the correctness conditions of the algorithm while the third condition is referred to as its convergence condition.
    </t>
    
    <t>Each assignment has a priority specified by the Node making the assignment, allowing for custom assignment policies. When multiple Nodes assign different prefixes from the same delegated prefix to the same link, or when multiple Nodes assign overlapping prefixes (to the same link or to different links), the assignment with the greatest priority is kept and other assignments are removed.</t>
    
    <t>The prefix assignment algorithm requires that participating Nodes share information through a flooding mechanism. If the flooding mechanism ensures that all messages are propagated to all Nodes within a given time window, the algorithm also ensures that all assigned prefixes used for networking operations (e.g., host configuration) remain unchanged, unless another Node assigns an overlapping prefix with a higher assignment priority, or the topology changes and renumbering cannot be avoided.</t>

</section>

<section anchor="terminology" title="Definitions">
    <t>In this document, the key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" are to be interpreted as described in <xref target='RFC2119' />.</t>
    
    <t>
        This document makes use of the following terminology. The terms defined here are ordered in such a way as to try to avoid forward references, and therefore are not sorted alphabetically.
        <list style="hanging">
            
            <t hangText="Node: ">An entity executing the algorithm specified in this document and able to communicate with other Nodes using the Flooding Mechanism.</t>

            <t hangText="Flooding Mechanism: ">A mechanism allowing participating Nodes to reliably share information with all other participating Nodes.</t>

            <t hangText="Link: ">An object the distributed algorithm will assign prefixes to. A Node may only assign prefixes to Links it is directly connected to. A Link is either Shared or Private.</t>

            <t hangText="Shared Link: ">A Link multiple Nodes may be connected to. Most of the time, a Shared Link is a multi-access link or point-to-point link, virtual or physical, requiring prefixes to be assigned to it.</t>

            <t hangText="Private Link: ">A Private Link is an abstract concept defined for the sake of this document. It allows Nodes to make assignments for their private use or delegation. For instance, every DHCPv6-PD <xref target='RFC3633' /> requesting router may be considered as a different Private Link.</t>

            <t hangText="Delegated Prefix: ">A prefix provided to the algorithm and used as a prefix pool for Assigned Prefixes.</t>

            <t hangText="Node ID: ">A value identifying a given participating Node. The set of identifiers MUST be strictly and totally ordered (e.g., using the alphanumeric order). The mechanism used to assign Node IDs, whether manual or automated, is out of the scope of this document.</t>

            <t hangText="Flooding Delay: ">A value which MUST be provided by the Flooding Mechanism and SHOULD be a deterministic or likely upper bound on the information propagation delay among participating Nodes.</t>

            <t hangText="Advertised Prefix: ">A prefix advertised by another Node and delivered to the local Node by the Flooding Mechanism. It has an Advertised Prefix Priority and, when assigned to a directly connected Shared Link, is associated with that Shared Link.</t>

            <t hangText="Advertised Prefix Priority: ">A value that defines the priority of an Advertised Prefix received from the Flooding Mechanism or a published Assigned Prefix. Whenever multiple Advertised Prefixes are conflicting (i.e., overlapping or from the same Delegated Prefix and assigned to the same link), all Advertised Prefixes but the one with the greatest priority will eventually be removed. In case of a tie, the assignment advertised by the Node with the greatest Node ID is kept and others are removed. In order to ensure convergence, the range of priority values MUST have an upper bound.</t>

            <t hangText="Assigned Prefix: ">A prefix included in a Delegated Prefix and assigned to a Shared or Private Link. It represents a local decision to assign a given prefix from a given Delegated Prefix to a given Link. The algorithm ensures that there is never more than one Assigned Prefix per Delegated Prefix and Link pair. When destroyed, an Assigned Prefix is set as not applied, ceases to be advertised, and is removed from the set of Assigned Prefixes.</t>

            <t hangText="Applied (Assigned Prefix): ">When an Assigned Prefix is applied, it MAY be used (e.g., for host configuration, routing protocol configuration, prefix delegation). When not applied, it MUST NOT be used for any purpose outside of the prefix assignment algorithm. Each Assigned Prefix is associated with a timer (Apply Timer) used to apply the Assigned Prefix. An Assigned Prefix is unapplied when destroyed.</t>

            <t hangText="Published (Assigned Prefix): ">The Assigned Prefix is advertised through the Flooding Mechanism as assigned to its associated Link. A published Assigned Prefix MUST have an Advertised Prefix Priority. It will appear as an Advertised Prefix to other Nodes, once received from the Flooding Mechanism.</t>

            <t hangText="Destroy (an Assigned Prefix): ">Local action of removing an Assigned Prefix from the set of Assigned Prefixes. If applied, the prefix is unapplied. If published, the prefix stops being advertised through the Flooding Mechanism.</t>

            <t hangText="Prefix Adoption: ">When an Advertised Prefix which does not conflict with any other Advertised Prefix or published Assigned Prefix stops being advertised, any other Node connected to the same Link may, after some random delay, start advertising the same prefix. This procedure is called adoption and provides seamless assignment transfer from a Node to another, e.g., in case of Node failure.</t>

            <t hangText="Backoff Timer: ">Every Delegated Prefix and Link pair is associated with a timer counting down to zero. It is used to reduce the probability of colliding assignments made by multiple Nodes by delaying the creation of new Assigned Prefixes or the advertisement of adopted Assigned Prefixes by a random amount of time.</t>

            <t hangText="Renumbering: ">Event occurring when an Assigned Prefix which was applied is destroyed. Renumbering is undesirable as it usually implies reconfiguring routers or hosts.</t>

        </list>
    </t>
    
    <section anchor="sr-terminology" title="Subroutine Specific Terminology">
        <t>In addition to the terms defined in <xref target="terminology"/>, the subroutine specified in <xref target="specs"/> makes use of the following terms.

            <list style="hanging">

                <t hangText="Current Assignment: ">For a given Delegated Prefix and Link, the Current Assignment is the Assigned Prefix (if any) included in the Delegated Prefix and assigned to the given Link by the Node executing the algorithm. At some point in time, the Current Assignment from different Nodes may differ, but the algorithm ensures that eventually, all Nodes directly connected to a Shared Link have the same Current Assignment for any given Delegated Prefix.</t>

                <t hangText="Precedence: ">An Advertised Prefix takes precedence over an Assigned Prefix if and only if one of the following conditions is met:
                    <list style="symbols">
                        <t>The Assigned Prefix is not published.</t>
                        <t>The Assigned Prefix is published and the Advertised Prefix Priority from the Advertised Prefix is strictly greater than the Advertised Prefix Priority from the Assigned Prefix.</t>
                        <t>The Assigned Prefix is published, the priorities are identical, and the Node ID from the Node advertising the Advertised Prefix is strictly greater than the local Node ID.</t>
                    </list>
                </t>

                <t hangText="Best Assignment: ">For a given Delegated Prefix and Link, the Best Assignment is computed as the unique Advertised Prefix (if any) that:
                    <list style="symbols">
                        <t>Includes or is included in the Delegated Prefix (i.e., the Advertised Prefix is a sub-prefix of the Delegated Prefix, or the Delegated Prefix is a sub-prefix of the Advertised Prefix).</t>
                        <t>Is assigned on the given Link.</t>
                        <t>Has the greatest Advertised Prefix Priority among Advertised Prefixes fulfilling the two preceding conditions (and, in case of a tie, the prefix advertised by the Node with the greatest Node ID among all prefixes with greatest priority).</t>
                        <t>Takes precedence over the Current Assignment associated with the same Link and Delegated Prefix (if any).</t>
                    </list>
                </t>

                <t hangText="Valid (Assigned Prefix): ">An Assigned Prefix is valid if and only if the following two conditions are met:
                    <list style="symbols">
                        <t>No Advertised Prefix including or included in the Assigned Prefix takes precedence over the Assigned Prefix.</t>
                        <t>No Advertised Prefix including or included in the same Delegated Prefix as the Assigned Prefix and assigned to the same Link takes precedence over the Assigned Prefix.</t>
                    </list>
                </t>
            </list>

        </t>
    </section>

</section>

<section title="Applicability Statement">

    <t>Although the algorithm was primarily designed as an autonomic prefix assignment tool for home networks, it is applicable to other areas. In particular, it can operate without any kind of configuration as well as using advanced prefix assignment rules. Additionally, it can be applied to any address space and can be used to manage multiple address spaces simultaneously. For instance, an implementation can make use of IPv4-mapped IPv6 addresses <xref target='RFC4291' /> in order to manage both IPv4 and IPv6 prefix assignment using a single prefix space.</t>
    
    <t>Each Node MUST have a set of non-overlapping Delegated Prefixes (i.e., which do not include each other). This set MAY change over time and be different from one Node to another at some point, but Nodes MUST eventually have the same set of non-overlapping Delegated Prefixes.</t>

    <!-- Otherwise correctness is not ensured -->
    
    <t>Given this set of non-overlapping Delegated Prefixes, Nodes may assign available prefixes from each Delegated Prefix to the Links they are directly connected to. The algorithm ensures that at most one prefix from a given Delegated Prefix is assigned to any given Link. Prefixes may also be assigned for private use. For example, an assigned prefix may be delegated to some other entity that does not implement this algorithm <xref target='RFC3633' />, or associated with a high priority in order to prevent other nodes from assigning any overlapping prefix <xref target='RFC6603' />.</t>

    <!--<t>The algorithm supports dynamically changing topologies:
        <list style="symbols">
            <t>Nodes may join or leave the set of participating Nodes.</t>
            <t>Nodes may join or leave Links.</t>
            <t>Links may be joined or split.</t>
        </list>
    </t>-->

    <t>The algorithm supports dynamically changing topologies and therefore will converge if the topology remains unmodified for a long enough period of time (That time depends on the Flooding Mechanism properties). Nevertheless, some topology changes may induce renumbering, while others do not. In particular, Nodes joining the set of participating Nodes do not cause renumbering. Similarly, Nodes leaving the network may be dealt with without renumbering by using the prefix adoption procedure. On the other hand, Links junction or split may break correctness conditions, and therefore cause renumbering.</t>

      <!--  Whenever part of the network would keep changing, the algorithm would be able to converge on the stable part of the network while it may keep changing the prefixes assigned to the network part that keeps changing. Which means that changes on part of the network will not affect distant parts of the network, unless Nodes joining and leaving the network </t>

    <t></t>-->

    <!--<t>Finally, topology changes affecting some part of the network will not induce renumbering to other parts of the network, unless the network is constantly splitting and joining again while some nodes try to assign overlapping prefixes (Such situation may happen due to misconfiguration or addressing space scarcity).</t>-->

    <!--<t>The algorithm supports dynamically changing topologies:
        <list style="symbols">
            <t>Nodes may join or leave the set of participating Nodes.</t>
            <t>Nodes may join or leave Links.</t>
            <t>Links may be joined or split.</t>
        </list>
        Such topology changes may cause renumbering. For instance, when two links are joined, each of which being assigned a prefix from a given delegated prefix, one of the two prefix is withdrawn.
    </t>-->
    
    <t>All Nodes MUST run a common Flooding Mechanism in order to share published Assigned Prefixes. The set of participating Nodes is defined as the set of Nodes participating in the Flooding Mechanism.</t>
    
    <t>The Flooding Mechanism MUST:
        <list style="symbols">
            <t>Provide a way to flood Assigned Prefixes assigned to a directly connected Link along with their respective Advertised Prefix Priority and the Node ID of the Node which is advertising them.</t>
            <t>Specify whether an Advertised Prefix is assigned to a directly connected Shared Link, and if so, on which one. This information also needs to be updated in case of links junction or split.</t>
            <t>Provide a Flooding Delay value, which SHOULD represent a deterministic or likely upper bound on the information propagation delay among participating Nodes. Whenever the Flooding Mechanism is unable to adhere to the provided Flooding Delay, renumbering may happen. As such a delay often depends on the size of the network, it MAY change over time and MAY be different from one Node to another. Furthermore, the process of selecting this value is subject to a tradeoff between convergence speed and lower renumbering probability (e.g., the value 0 may be used when renumbering is harmless), and is therefore out of scope of this document.</t>
        </list>
    </t>

    <t>The algorithm ensures that whenever the Flooding Delay is provided and held, and in the absence of any topology change or Delegated Prefix removal, renumbering only happens when a Node deliberately overrides an existing assignment. In the absence of such deliberate override, the algorithm converges within an absolute worst case timespan of '2 * Flooding Delay * L' seconds, where L in the number of links.</t>
    
    <t>Each Node MUST have a Node ID. In the absence of colliding assignments, the algorithm will not suffer from multiple nodes having the same Node ID, but in order for collisions to be resolved, such situation MUST be transient.</t>
        <!--<t>Node IDs MAY change over time and be the same on multiple Nodes at some point, but each Node MUST eventually have a Node ID which is unique among the set of participating Nodes.</t>-->

    <t>Finally, leaving the Flooding Mechanism or Node ID assignment process unsecured makes the network vulnerable to deny of service attacks, as detailed in <xref target='security' />. Additionally, as this algorithm requires all Nodes to know which Node has made which assignment, it may be unsuitable depending on privacy requirements among participating Nodes.</t>
    
</section>

<section anchor="specs" title="Algorithm Specification">
    
    <t>This section specifies the behavior of Nodes implementing the prefix assignment algorithm. The terms 'Current Assignment', 'Precedence', 'Best Assignment' and 'Valid' are used as defined in <xref target="sr-terminology"/>.</t>
    
    <section anchor="algo" title="Prefix Assignment Algorithm Subroutine">
        <t>This section specifies the prefix assignment algorithm subroutine. It is defined for a given Delegated Prefix and Link pair and takes a BackoffTriggered boolean as parameter (indicating whether the subroutine execution was triggered by the Backoff Timer or by another event). The subroutine also makes use of the two following configuration parameters: ADOPT_MAX_DELAY and BACKOFF_MAX_DELAY, which meanings are detailed in <xref target='variables' />.</t>
        
        <t>
            For a given Delegated Prefix and Link pair, the subroutine MUST be run with the BackoffTriggered boolean set to false whenever:
            <list style="symbols">
                <t>An Advertised Prefix including or included in the considered Delegated Prefix is added or removed.</t>
                <t>An Assigned Prefix included in the considered Delegated Prefix and associated with a different Link than the considered Link was destroyed, while there is no Current Assignment associated with the given pair. This case MAY be ignored if the creation of a new Assigned Prefix associated with the considered pair is not desired.</t>
                <t>The considered Delegated Prefix is added.</t>
                <t>The considered Link is added.</t>
                <t>The Node ID is modified.</t>
                <t>An Assigned Prefix included in the considered Delegated Prefix and associated with the considered Link is destroyed outside of the context of the subroutine, as specified in <xref target='override' />.</t>
            </list>
            
            Furthermore, for a given Delegated Prefix and Link pair, the subroutine MUST be run with the BackoffTriggered boolean set to true whenever:
            <list style="symbols">
                <t>The Backoff Timer associated with the considered Delegated Prefix and Link pair fires while there is no Current Assignment associated with the given pair.</t>
            </list>
        </t>
        
        <t>When such an event occurs, a Node MAY delay the execution of the subroutine instead of executing it immediately, e.g., while receiving an update from the Flooding Mechanism, or for security reasons (see <xref target='security' />). Even if other events occur in the meantime, the subroutine MUST be run only once. It is also assumed that, whenever one of these events is the Backoff Timer firing while there is no Current Assignment associated with the given pair, the subroutine is executed with the BackoffTriggered boolean set to true.</t>
        
        <t>In order to execute the subroutine for a given Delegated Prefix and Link pair, first get the Current Assignment and compute the Best Assignment associated with the Delegated Prefix and Link pair, then execute the corresponding case:
            <list style="numbers">
                <t>If there is no Best Assignment and no Current Assignment: Decide whether the creation of a new assignment for the given Delegated Prefix and Link pair is desired (As any result would be valid, the process of making this decision is out of the scope of this document) and do the following:
                    <list style="symbols">
                        <t>If it is not desired, stop the execution of the subroutine.</t>
                        <t>Else if the Backoff Timer is running, stop the execution of the subroutine.</t>
                        <t>Else if the BackoffTriggered boolean is set to false, set the Backoff Timer to some random delay between ADOPT_MAX_DELAY and BACKOFF_MAX_DELAY (see <xref target='variables' />) and stop the execution of the subroutine.</t>
                        <t>Else, continue the execution of the subroutine.</t>
                    </list>
                    Select a prefix for the new assignment (see <xref target='random' /> for guidance regarding prefix selection). This prefix MUST be included in or be equal to the considered Delegated Prefix and MUST NOT include or be included in any Advertised Prefix. If a suitable prefix is found, use it to create a new Assigned Prefix:
                    <list style="symbols">
                        <t>Assigned to the considered Link.</t>
                        <t>Set as not applied.</t>
                        <t>The Apply Timer set to '2 * Flooding Delay'.</t>
                        <t>Published with some selected Advertised Prefix Priority.</t>
                    </list>
                </t>
                <t>If there is a Best Assignment but no Current Assignment: First check if the Best Assignment is equal to or included in the Delegated Prefix. If not, stop the execution of the subroutine. Otherwise, cancel the Backoff Timer and use the prefix from the Best Assignment to create a new Assigned Prefix:
                    <list style="symbols">
                        <t>Assigned to the considered Link.</t>
                        <t>Set as not applied.</t>
                        <t>The Apply Timer set to '2 * Flooding Delay'.</t>
                        <t>Set as not published.</t>
                    </list>
                </t>
                <t>If there is a Current Assignment but no Best Assignment:
                    <list style="symbols">
                        <t>If the Current Assignment is not valid, destroy it, and execute the subroutine again with the BackoffTriggered boolean set to false.</t>
                        <t>If the Current Assignment is valid and published, stop the execution of the subroutine.</t>
                        <t>If the Current Assignment is valid and not published, the Node MUST either:
                            <list style="symbols">
                                <t>Adopt the prefix by canceling the Apply Timer and set the Backoff Timer to some random delay between 0 and ADOPT_MAX_DELAY (see <xref target='variables' />). This procedure is used to avoid renumbering when the Node advertising the prefix left the Shared Link, and SHOULD therefore be preferred.</t>
                                <t>Destroy it and go to case 1, allowing a different prefix to be assigned, or the prefix to be removed. When the Current Assignment is applied, this causes renumbering.</t>
                            </list>
                        </t>
                    </list>
                </t>
                <t>If there is a Current Assignment and a Best Assignment:
                    <list style="symbols">
                        <t>Cancel the Backoff Timer.</t>
                        <t>If the two prefixes are identical, set the Current Assignment as not published. If the Current Assignment is not applied and the Apply Timer is not set, set the Apply Timer to '2 * Flooding Delay'.</t>
                        <t>If the two prefixes are not identical, destroy the Current Assignment and go to case 2.</t>
                    </list>
                </t>
            </list>
        </t>
        
        <t>When the prefix assignment algorithm subroutine requires an assignment to be created or adopted, any Advertised Prefix Priority value can be used. Other documents MAY provide restrictions over this value depending on the context the algorithm is operating in, or leave it as implementation-specific.</t>

    </section>
    
    
    <section anchor="override" title="Overriding and Destroying Existing Assignments">
        <t>In addition to the behaviors specified in <xref target='algo' />, the following procedures MAY be used in order to provide additional <xref target='behavior'>behavior options</xref>:
            <list style="hanging">
                <t hangText="Overriding Existing Assignments: ">For any given Link and Delegated Prefix, a Node MAY create a new Assigned Prefix using a chosen prefix and Advertised Prefix Priority such that:
                    <list style="symbols">
                        <t>The chosen prefix is included in or is equal to the considered Delegated Prefix.</t>
                        <t>The Current Assignment, if any, as well as all existing Assigned Prefixes which include or are included inside the chosen prefix, are destroyed.</t>
                        <t>It is not applied.</t>
                        <t>The Apply Timer is set to '2 * Flooding Delay'.</t>
                        <t>It is published.</t>
                        <t>The Advertised Prefix Priority is greater than the Advertised Prefix Priority from all Advertised Prefixes which include or are included in the chosen prefix.</t>
                        <t>The Advertised Prefix Priority is greater than the Advertised Prefix Priority from all Advertised Prefixes which include or are included in the considered Delegated Prefix and are assigned to the considered Link.</t>
                    </list>
                    In order to ensure algorithm convergence:
                    <list style="symbols">
                        <t>Such overriding assignments MUST NOT be created unless there was a change in the Node configuration, a Link was added, or an Advertised Prefix was added or removed.</t>
                        <t>The chosen Advertised Prefix Priority for the new Assigned Prefix SHOULD be greater than all priorities from the destroyed Assigned Prefixes. If not, simple topologies with only two Nodes may not converge. Nodes which do not adhere to this rule MUST implement a mechanism which detects whether the distributed algorithm does not converge and, whenever this would happen, stop creating overriding Assigned Prefixes which do not adhere to this rule. The specifications for such safety procedures are out of the scope of this document.</t>
                    </list>
                </t>
                <t hangText="Removing an Assigned Prefix: ">A Node MAY destroy any Assigned Prefix which is published. Such an event reflects the desire of a Node to not assign a prefix from a given Delegated Prefix to a given Link anymore. In order to ensure algorithm convergence, such a procedure MUST NOT be executed unless there was a change in the Node configuration. Furthermore, whenever an Assigned Prefix is destroyed in this way, the prefix assignment algorithm subroutine MUST be run for the Delegated Prefix and Link pair associated with the destroyed Assigned Prefix.</t>
            </list>
        
        </t>
        <t>The two procedures specified in this section are OPTIONAL. They could be used for various purposes, e.g., for providing custom prefix assignment configuration or reacting to prefix space exhaustion (by overriding short Assigned Prefixes and assigning longer ones).</t>
    </section>
    
    <section anchor="other" title="Other Events">
        <t>When the Apply Timer fires, the associated Assigned Prefix MUST be applied.</t>
        
        <t>When the Backoff Timer associated with a given Delegated Prefix and Link pair fires while there is a Current Assignment associated with the same pair, the Current Assignment MUST be published with some associated Advertised Prefix Priority and, if the prefix is not applied, the Apply Timer MUST be set to '2 * Flooding Delay'.</t>
        
        <t>When a Delegated Prefix is removed from the set of Delegated Prefixes (e.g., when the Delegated Prefix expires), all Assigned Prefixes included in the removed Delegated Prefix MUST be destroyed.</t>
        
        <t>When one Delegated Prefix is replaced by another one that includes or is included in the deleted Delegated Prefix, all Assigned Prefixes which were included in the deleted Delegated Prefix but are not included in the added Delegated Prefix MUST be destroyed. Others MAY be kept.</t>
        
        <t>When a Link is removed, all Assigned Prefixes assigned to that Link MUST be destroyed.</t>
    </section>
    
</section>

<section anchor="random" title="Prefix Selection Considerations">
    <t>When the prefix assignment algorithm subroutine specified in <xref target='algo' /> requires a new prefix to be selected, the prefix MUST be selected either:
            <list style="symbols">
                <t>Among prefixes included in the considered Delegated Prefix which were previously assigned and applied on the considered Link. For that purpose, Applied Prefixes may be stored in stable storage along with their associated Link.</t>
                <t>Randomly, picked in a set of at least RANDOM_SET_SIZE (see <xref target='variables' />) prefixes included in the considered Delegated Prefix and not including or included in any Assigned or Advertised Prefix. If less than RANDOM_SET_SIZE candidates are found, the prefix MUST be picked among all candidates.</t>
                <t>Based on some custom selection process specified in the configuration.</t>
            </list>
        
        A simple implementation MAY randomly pick the prefix among all available prefixes, but this strategy is inefficient in terms of address space use as a few long prefixes may exhaust the pool of available short prefixes.</t>
    
    <t>The rest of this section describes a more efficient approach which MAY be applied any time a Node needs to pick a prefix for a new assignment. The two following definitions are used:
        <list style="hanging">
            <t hangText="Available prefix: ">The prefix of the form Prefix/PrefixLength is available if and only if it satisfies the three following conditions:
                    <list style="symbols">
                        <t>It is included in the considered Delegated Prefix.</t>
                        <t>It does not include and is not included in any Assigned or Advertised Prefix.</t>
                        <t>It is equal to the considered Delegated Prefix or Prefix/(PrefixLength-1) includes an Assigned or Advertised Prefix.</t>
                    </list>
               </t>
            <t hangText="Candidate prefix: ">A prefix of desired length which is included in or is equal to an available prefix.</t>
        </list>
    </t>
    
    <t>The procedure described in this section takes the three following criteria into account:
        <list style="hanging">
            <t hangText="Prefix Stability: ">In some cases, it is desirable that the selected prefix should remain the same across executions and reboots. For this purpose, prefixes previously applied on the Link or pseudo-random prefixes generated based on Node- and Link-specific values may be considered.</t>
            <t hangText="Randomness: ">When no stored or pseudo-random prefix is chosen, a prefix may be randomly picked among RANDOM_SET_SIZE candidates of desired length. If less than RANDOM_SET_SIZE candidates can be found, the prefix is picked among all candidates.</t>
            <t hangText="Addressing-space usage efficiency: ">In the process of assigning prefixes, a small set of badly chosen long prefixes may prevent any shorter prefix from being assigned. For this reason, the set of RANDOM_SET_SIZE candidates is created from available prefixes with longest prefix lengths and, in case of a tie, preferring numerically small prefix values.</t>
        </list>
    </t>
    
    <t>When executing the procedure, do as follows:
        <list style="numbers">
            <t>For each prefix stored in stable storage, check if the prefix is included in or equal to an available prefix. If so, pick that prefix and stop.</t>
            <t>For each prefix length, count the number of available prefixes of the given length.</t>
            <t>If the desired prefix length was not specified, select one. The available prefixes count computed previously may be used to help pick a prefix length such that:
                    <list style="symbols">
                        <t>There is at least one candidate prefix.</t>
                        <t>The prefix length is chosen large enough to not exhaust the address space.</t>
                    </list>
                Let N be the chosen prefix length.</t>
            <t>Iterate over available prefixes starting with prefixes of length N down to length 0 and create a set of RANDOM_SET_SIZE candidate prefixes of length exactly N included in or equal to available prefixes. The end goal here is to create a set of RANDOM_SET_SIZE candidate prefixes of length N included in a set of available prefixes of maximized prefix length. In case of a tie, smaller prefix values (as defined by the bit-wise lexicographical order) are preferred.</t>
            <t>Generate a set of prefixes of desired length, which are pseudo-randomly chosen based on Node- and Link-specific values. For each pseudo-random prefix, check if the prefix is equal to a candidate prefix. If so, pick that prefix and stop.</t>
            <t>Choose a random prefix from the set of selected candidates.</t>
        </list>
    </t>
    
    <t>The complexity of this procedure is equivalent to the complexity of iterating over available prefixes. Such operation may be accomplished in linear time, e.g., by storing Advertised and Assigned Prefixes in a binary trie.</t>
    
</section>

<section anchor="behavior" title="Implementation Capabilities and Node Behavior">
    <t>Implementations of the prefix assignment algorithm may vary from very basic to highly customizable, enabling different types of fully interoperable behaviors. The three following behaviors are given as examples:
        <list style="hanging">
            <t hangText="Listener: ">The Node only acts upon assignments made by other Nodes, i.e, it never creates new assignments nor adopts existing ones. Such behavior does not require the implementation of the considerations specified in <xref target='random' /> or <xref target='override' />. The Node never checks the validity of existing assignments, which makes this behavior particularly suited to lightweight devices which can rely on more capable neighbors to make assignments on directly connected Shared Links.</t>
            <t hangText="Basic: ">The Node is capable of assigning new prefixes or adopting prefixes which do not conflict with any other existing assignment. Such behavior does not require the implementation of the considerations specified in <xref target='override' />. It is suited to situations where there is no preference over which prefix should be assigned to which Link, and there is no priority between different Links.</t>
            <t hangText="Advanced: ">The Node is capable of assigning new prefixes, adopting existing ones, making overriding assignments and destroying existing ones. Such behavior requires the implementation of the considerations specified in <xref target='random' /> and <xref target='override' />. It is suited when the administrator desires some particular prefix to be assigned on a given Link, or some Link to be assigned prefixes with a greater priority when there are not enough prefixes available for all Links.</t>
        </list>

        Note that if all Nodes directly connected to some Link are listener Nodes or none of these Nodes are willing to make an assignment from a given Delegated Prefix to the given Link, no prefix from the given Delegated Prefix will ever be assigned to the Link. This situation may be detected by watching whether no prefix from a given Delegated Prefix has been assigned to the Link for longer than BACKOFF_MAX_DELAY plus the Flooding Delay.
    </t>
    
</section>

<section anchor="variables" title="Algorithm Parameters">
    <t>This document does not provide values for ADOPT_MAX_DELAY, BACKOFF_MAX_DELAY and RANDOM_SET_SIZE. The algorithm ensures convergence and correctness for any chosen values, even when these are different from Node to Node. They MAY be adjusted depending on the context, providing a tradeoff between convergence time, efficient addressing, reduced control traffic (generated by the Flooding Mechanism), and low collision probability.</t>
    
    <t>ADOPT_MAX_DELAY (respectively BACKOFF_MAX_DELAY) represents the maximum backoff time a Node may wait before adopting an assignment (respectively making a new assignment). BACKOFF_MAX_DELAY MUST be greater than or equal to ADOPT_MAX_DELAY. The greater ADOPT_MAX_DELAY and (BACKOFF_MAX_DELAY - ADOPT_MAX_DELAY), the lower the collision probability and the lesser the amount of control traffic, but the greater the convergence time.</t>
    <t>RANDOM_SET_SIZE represents the desired size of the set a random prefix will be picked from. The greater RANDOM_SET_SIZE, the better the convergence time and the lower the collision probability, but the worse the addressing-space usage efficiency.</t>

</section>

<section anchor="security" title="Security Considerations">
    <t>The prefix assignment algorithm functions on top of two distinct mechanisms, the Flooding Mechanism and the Node ID assignment mechanism.
        <list>
            <t>An attacker able to publish Advertised Prefixes through the Flooding Mechanism may perform the following attacks:
                <list style="symbols">
                    <t>Publish a single overriding assignment for a whole Delegated Prefix or for the whole address space, thus preventing any Node from assigning prefixes to Links.</t>
                    <t>Quickly publish and remove Advertised Prefixes, generating traffic at the Flooding Mechanism layer and causing multiple executions of the prefix assignment algorithm in all participating Nodes.</t>
                    <t>Publish and remove Advertised Prefixes in order to prevent the convergence of the algorithm.</t>
                </list>
            </t>
            <t>An attacker able to prevent other Nodes from accessing a portion or the whole set of Advertised Prefixes may compromise the correctness of the algorithm.</t>
            <t>An attacker able to cause repetitive Node ID changes may cause traffic to be generated in the Flooding Mechanism and multiple executions of the prefix assignment algorithm in all participating Nodes.</t>
            <t>An attacker able to publish Advertised Prefixes using a Node ID used by another Node may impede the ability to resolve prefix assignment collisions.</t>
        </list>
    </t>
    <t>Whenever the security of the Flooding Mechanism and Node ID assignment mechanism cannot be ensured, the convergence of the algorithm may be prevented. In environments where such attacks may be performed, the execution of the prefix assignment algorithm subroutine SHOULD be rate limited, as specified in <xref target='algo' />.</t>
</section>

<section title="IANA Considerations">
    <t>This document has no actions for IANA.</t>
</section>

<section title="Acknowledgments">
    
    <t>The authors would like to thank those who participated in the previous document's version development as well as the present one. In particular, the authors would like to thank Tim Chown, Fred Baker, Mark Townsley, Lorenzo Colitti, Ole Troan, Ray Bellis, Markus Stenberg, Wassim Haddad, Joel Halpern, Samita Chakrabarti, Michael Richardson, Anders Brandt, Erik Nordmark, Laurent Toutain, Ralph Droms, Acee Lindem, Steven Barth and Juliusz Chroboczek for interesting discussions and document review.</t>
    
</section>

</middle>

<back>

<references title="Normative References">
  <?rfc include="reference.RFC.2119.xml"?>
</references>

<references title="Informative References">
  <?rfc include="reference.RFC.3633.xml"?>
  <?rfc include="reference.RFC.4291.xml"?>
  <?rfc include="reference.RFC.6603.xml"?>
</references>



<section anchor="static" title="Static Configuration Example">
    <t>This section describes an example of how custom configuration of the prefix assignment algorithm may be implemented.</t>
    <t>The Node configuration is specified as a finite set of rules. A rule is defined as:
        <list style="symbols">
            <t>A prefix to be used.</t>
            <t>A Link on which the prefix may be assigned.</t>
            <t>An Assigned Prefix Priority (smallest possible Assigned Prefix Priority if the rule may not override other Assigned Prefixes).</t>
            <t>A rule priority (0 if the rule may not override existing Advertised Prefixes).</t>
        </list>
        
        In order to ensure the convergence of the algorithm, the Assigned Prefix Priority MUST be an increasing function (not necessarily strictly) of the configuration rule priority (i.e., the greater is the configuration rule priority, the greater the Assigned Prefix Priority must be).
    </t>
    <t>Each Assigned Prefix is associated with a rule priority. Assigned Prefixes which are created as specified in <xref target='algo' /> are given a rule priority of 0.</t>
    <t>Whenever the configuration is changed or the prefix assignment algorithm subroutine is run: For each Link/Delegated Prefix pair, look for the configuration rule with the greatest configuration rule priority such that:
        <list style="symbols">
            <t>The prefix specified in the configuration rule is included in the considered Delegated Prefix.</t>
            <t>The Link specified in the configuration rule is the considered Link.</t>
            <t>All the Assigned Prefixes which would need to be destroyed in case a new Assigned Prefix is created from that configuration rule (as specified in <xref target='override' />) have an associated rule priority which is strictly lower than the one of the considered configuration rule.</t>
            <t>The assignment would be valid when published with an Advertised Prefix Priority equal to the one specified in the configuration rule.</t>
        </list>
        If a rule is found, a new Assigned Prefix is created based on that rule as specified in <xref target='override' />. The new Assigned Prefix is associated with the Advertised Prefix Priority and the rule priority specified in the considered configuration rule.
    </t>
    
    <t>Note that the use of rule priorities ensures the convergence of the algorithm.</t>
</section>

</back>
</rfc>
